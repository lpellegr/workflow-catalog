/*
 *  ProActive Parallel Suite(TM): The Java(TM) library for
 *     Parallel, Distributed, Multi-Core Computing for
 *     Enterprise Grids & Clouds
 *
 *  Copyright (C) 1997-2016 INRIA/University of
 *                  Nice-Sophia Antipolis/ActiveEon
 *  Contact: proactive@ow2.org or contact@activeeon.com
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Affero General Public License
 *  as published by the Free Software Foundation; version 3 of
 *  the License.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
 *  USA
 *
 *  If needed, contact us to obtain a release under GPL Version 2 or 3
 *  or a different license than the AGPL.
 *
 *  Initial developer(s):               The ProActive Team
 *                          http://proactive.inria.fr/team_members.htm
 */
package org.ow2.proactive.workflow_catalog.rest.query;

import com.google.common.collect.ImmutableMap;
import com.mysema.query.BooleanBuilder;
import com.mysema.query.types.Predicate;
import org.ow2.proactive.workflow_catalog.rest.entity.QGenericInformation;
import org.ow2.proactive.workflow_catalog.rest.entity.QVariable;
import org.ow2.proactive.workflow_catalog.rest.entity.QWorkflowRevision;
import org.ow2.proactive.workflow_catalog.rest.query.parser.WorkflowCatalogQueryLanguageBaseVisitor;
import org.ow2.proactive.workflow_catalog.rest.query.parser.WorkflowCatalogQueryLanguageParser;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * The concrete visitor that will create the predicate based
 * on the AST generated by {@link WorkflowCatalogQueryCompiler}
 *
 * @author ActiveEon Team
 */
public class WorkflowCatalogQueryLanguageVisitor extends WorkflowCatalogQueryLanguageBaseVisitor<BooleanBuilder> {

    private final static String NEQ = "!=";
    private final static String EQ = "=";
    private final static String VAR_TOKEN = "variable";
    private final static String GI_TOKEN = "generic_information";
    private final static String NAME_TOKEN = "name";
    private final static String PROJ_TOKEN = "project_name";
    private final static String NAME_KEYWORD = "name";
    private final static String VALUE_KEYWORD = "value";

    private final Map<ClauseKey, Function<String, Predicate>> CLAUSES_TO_FUNC_MAP;

    private QGenerator generator = new QGenerator();

    public WorkflowCatalogQueryLanguageVisitor() {
        CLAUSES_TO_FUNC_MAP = initClausesToFuncMap();
    }

    @Override
    public BooleanBuilder visitExpression(WorkflowCatalogQueryLanguageParser.ExpressionContext ctx) {
        return visitAnd_expression(ctx.and_expression());
    }

    @Override
    public BooleanBuilder visitAnd_expression(WorkflowCatalogQueryLanguageParser.And_expressionContext ctx) {
        BooleanBuilder booleanBuilder = new BooleanBuilder();
        for (WorkflowCatalogQueryLanguageParser.Or_expressionContext orExpressionContext : ctx.or_expression()) {
            booleanBuilder.and(visit(orExpressionContext));
        }
        return booleanBuilder;
    }

    @Override
    public BooleanBuilder visitOr_expression(WorkflowCatalogQueryLanguageParser.Or_expressionContext ctx) {
        BooleanBuilder booleanBuilder = new BooleanBuilder();
        for (WorkflowCatalogQueryLanguageParser.ClauseContext clauseContext : ctx.clause()) {
            booleanBuilder.or(visit(clauseContext));
        }
        return booleanBuilder;
    }

    public BooleanBuilder visitFinalClause(WorkflowCatalogQueryLanguageParser.FinalClauseContext ctx) {

        String attributeLiteral = ctx.AttributeLiteral().getText();
        String stringLiteral = ctx.StringLiteral().getText();

        // a String literal always starts and ends by a " character
        // remove leading and trailing " character
        stringLiteral = stringLiteral.substring(1, stringLiteral.length() - 1);

        BooleanBuilder booleanBuilder = new BooleanBuilder();

        ClauseKey.TABLE table = getTable(attributeLiteral);
        ClauseKey.OPERATION operation = getOperation(ctx.COMPARE_OPERATOR().getText());
        ClauseKey.CLAUSE_TYPE clauseType = getClauseType(attributeLiteral);

        Pattern wildcardPattern = Pattern.compile(".*[^\\\\]%.*");
        Matcher wildcardMatcher = wildcardPattern.matcher(attributeLiteral);
        boolean hasWildcards = wildcardMatcher.matches();
        ClauseKey clauseKey = new ClauseKey(table, operation, clauseType, hasWildcards);
        Function<String, Predicate> predicateCreator = CLAUSES_TO_FUNC_MAP.get(clauseKey);

        if (predicateCreator == null) {
            throw new QueryPredicateBuilderRuntimeException("No predicate found for clause '" + clauseKey + "'");
        }

        return booleanBuilder.and(predicateCreator.apply(stringLiteral));
    }

    public BooleanBuilder visitParenthesedClause(WorkflowCatalogQueryLanguageParser.ParenthesedClauseContext ctx) {
        return visitAnd_expression(ctx.and_expression());
    }

    protected ClauseKey.TABLE getTable(String attributeName) {
        String[] terms = attributeName.split(Pattern.quote("."));

        if (terms.length > 1) {
            if (terms[0].equalsIgnoreCase(VAR_TOKEN)) {
                return ClauseKey.TABLE.VARIABLE;
            } else if (terms[0].equalsIgnoreCase(GI_TOKEN)) {
                return ClauseKey.TABLE.GENERIC_INFORMATION;
            }
        } else {
            if (terms[0].equalsIgnoreCase(NAME_TOKEN)) {
                return ClauseKey.TABLE.NAME;
            } else if (terms[0].equalsIgnoreCase(PROJ_TOKEN)) {
                return ClauseKey.TABLE.PROJECT_NAME;
            }
        }

        throw new QueryPredicateBuilderRuntimeException("Invalid attribute name '" + attributeName + "'");
    }

    protected ClauseKey.OPERATION getOperation(String operation) {
        if (operation.contentEquals(EQ)) {
            return ClauseKey.OPERATION.EQUAL;
        } else if (operation.contentEquals(NEQ)) {
            return ClauseKey.OPERATION.NOT_EQUAL;
        } else {
            throw new QueryPredicateBuilderRuntimeException("Operator '" + operation + "' is invalid");
        }
    }

    protected ClauseKey.CLAUSE_TYPE getClauseType(String attributeLiteral) {
        ClauseKey.TABLE table = getTable(attributeLiteral);
        if (table == ClauseKey.TABLE.VARIABLE || table == ClauseKey.TABLE.GENERIC_INFORMATION) {
            String[] terms = attributeLiteral.split(Pattern.quote("."));

            assert terms.length > 1;

            if (terms[1].equalsIgnoreCase(NAME_KEYWORD)) {
                return ClauseKey.CLAUSE_TYPE.KEY;
            } else if (terms[1].equalsIgnoreCase(VALUE_KEYWORD)) {
                return ClauseKey.CLAUSE_TYPE.VALUE;
            } else {
                throw new QueryPredicateBuilderRuntimeException("Clause type found in '" + attributeLiteral + "' is invalid");
            }
        } else if (table == ClauseKey.TABLE.NAME || table == ClauseKey.TABLE.PROJECT_NAME) {
            return ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE;
        } else {
            throw new QueryPredicateBuilderRuntimeException("Clause '" + attributeLiteral + "' is invalid");
        }
    }

    public QGenerator getGenerator() {
        return generator;
    }

    private Map<ClauseKey, Function<String, Predicate>> initClausesToFuncMap() {
        Map<ClauseKey, Function<String, Predicate>> map = new HashMap<>(32);

        map.put(new ClauseKey(ClauseKey.TABLE.VARIABLE, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.KEY, false),
                literalString -> generator.createVariableAlias().key.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.VARIABLE, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.KEY, false),
                literalString -> generator.createVariableAlias().key.ne(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.VARIABLE, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.VALUE, false),
                literalString -> generator.createVariableAlias().value.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.VARIABLE, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.VALUE, false),
                literalString -> generator.createVariableAlias().value.ne(literalString));

        map.put(new ClauseKey(ClauseKey.TABLE.GENERIC_INFORMATION, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.KEY, false),
                literalString -> generator.createGenericInformationAlias().key.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.GENERIC_INFORMATION, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.KEY, false),
                literalString -> generator.createGenericInformationAlias().key.ne(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.GENERIC_INFORMATION, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.VALUE, false),
                literalString -> generator.createGenericInformationAlias().value.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.GENERIC_INFORMATION, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.VALUE, false),
                literalString -> generator.createGenericInformationAlias().value.ne(literalString));

        map.put(new ClauseKey(ClauseKey.TABLE.NAME, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, false),
                literalString -> QWorkflowRevision.workflowRevision.name.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.NAME, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, false),
                literalString -> QWorkflowRevision.workflowRevision.name.ne(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.NAME, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, false),
                literalString -> QWorkflowRevision.workflowRevision.name.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.NAME, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, false),
                literalString -> QWorkflowRevision.workflowRevision.name.ne(literalString));

        map.put(new ClauseKey(ClauseKey.TABLE.PROJECT_NAME, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, false),
                literalString -> QWorkflowRevision.workflowRevision.projectName.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.PROJECT_NAME, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, false),
                literalString -> QWorkflowRevision.workflowRevision.projectName.ne(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.PROJECT_NAME, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, false),
                literalString -> QWorkflowRevision.workflowRevision.projectName.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.PROJECT_NAME, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, false),
                literalString -> QWorkflowRevision.workflowRevision.projectName.ne(literalString));

        map.put(new ClauseKey(ClauseKey.TABLE.VARIABLE, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.KEY, true),
                literalString -> generator.createVariableAlias().key.like(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.VARIABLE, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.KEY, true),
                literalString -> generator.createVariableAlias().key.notLike(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.VARIABLE, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.VALUE, true),
                literalString -> generator.createVariableAlias().value.like(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.VARIABLE, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.VALUE, true),
                literalString -> generator.createVariableAlias().value.notLike(literalString));

        map.put(new ClauseKey(ClauseKey.TABLE.GENERIC_INFORMATION, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.KEY, true),
                literalString -> generator.createGenericInformationAlias().key.like(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.GENERIC_INFORMATION, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.KEY, true),
                literalString -> generator.createGenericInformationAlias().key.notLike(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.GENERIC_INFORMATION, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.VALUE, true),
                literalString -> generator.createGenericInformationAlias().value.like(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.GENERIC_INFORMATION, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.VALUE, true),
                literalString -> generator.createGenericInformationAlias().value.notLike(literalString));

        map.put(new ClauseKey(ClauseKey.TABLE.NAME, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, true),
                literalString -> QWorkflowRevision.workflowRevision.name.like(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.NAME, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, true),
                literalString -> QWorkflowRevision.workflowRevision.name.notLike(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.NAME, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, true),
                literalString -> QWorkflowRevision.workflowRevision.name.like(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.NAME, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, true),
                literalString -> QWorkflowRevision.workflowRevision.name.notLike(literalString));

        map.put(new ClauseKey(ClauseKey.TABLE.PROJECT_NAME, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, true),
                literalString -> QWorkflowRevision.workflowRevision.projectName.like(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.PROJECT_NAME, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, true),
                literalString -> QWorkflowRevision.workflowRevision.projectName.notLike(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.PROJECT_NAME, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, true),
                literalString -> QWorkflowRevision.workflowRevision.projectName.like(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.PROJECT_NAME, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, true),
                literalString -> QWorkflowRevision.workflowRevision.projectName.notLike(literalString));

        return ImmutableMap.copyOf(map);
    }

    public static class QGenerator {

        private int index = 0;

        private Set<QGenericInformation> qGenericInformation;

        private Set<QVariable> qVariables;

        public QGenericInformation createGenericInformationAlias() {
            QGenericInformation qGenericInformation = new QGenericInformation("genericInformation" + index);
            this.qGenericInformation.add(qGenericInformation);
            index++;
            return qGenericInformation;
        }

        public QVariable createVariableAlias() {
            QVariable qVariable = new QVariable("variable" + index);
            this.qVariables.add(qVariable);
            index++;
            return qVariable;
        }

        public int getIndex() {
            return index;
        }

        public void setIndex(int index) {
            this.index = index;
        }

        public Set<QGenericInformation> getqGenericInformation() {
            return qGenericInformation;
        }

        public void setqGenericInformation(Set<QGenericInformation> qGenericInformation) {
            this.qGenericInformation = qGenericInformation;
        }

        public Set<QVariable> getqVariables() {
            return qVariables;
        }

        public void setqVariables(Set<QVariable> qVariables) {
            this.qVariables = qVariables;
        }
    }

}
